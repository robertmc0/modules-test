@description('The name of the existing Front Door/CDN Profile.')
param profileName string

@description('Endpoints to deploy to Frontdoor.')
@metadata(
  {
    doclink: 'https://learn.microsoft.com/en-us/azure/templates/microsoft.cdn/profiles/afdendpoints?pivots=deployment-language-bicep'
    example: [
      {
        name: 'myendpoint' // name of endpoint
        enabledState: 'Enabled' // Optional. Enabled state of endpoint. 'Enabled' or 'Disabled'
        autoGeneratedDomainNameLabelScope: 'TenantReuse' // Optional. Indicates the endpoint name reuse scope. The default value is TenantReuse.
      }
    ]
  }
)
param endpoints array

@description('Origin Groups to deploy to Frontdoor.')
@metadata({
  doclink: 'https://learn.microsoft.com/en-us/azure/templates/microsoft.cdn/profiles/origingroups?pivots=deployment-language-bicep'
  example: {
    name: 'myOriginGroup'
    loadBalancingSettings: { // Optional. Load balancing settings for a backend pool
      sampleSize: 5
      successfulSamplesRequired: 3
      additionalLatencyInMilliseconds: 240
    }
    healthProbeSettings: { // Optional. Health probe settings to the origin that is used to determine the health of the origin param.
      probePath: '/'
      probeRequestType: 'HEAD'
      probeProtocol: 'Http'
      probeIntervalInSeconds: '240'
    }
    sessionAffinityState: 'Enabled' // Optional. Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
  }
})
param originGroups array

@description('Origins to deploy to Frontdoor.')
@metadata({
  docclink: 'https://learn.microsoft.com/en-us/azure/templates/microsoft.cdn/profiles/origingroups/origins?pivots=deployment-language-bicep'
  example: {
    enabledState: true // Optional.
    originGroupName: 'myOriginGroup' // Name must match with the origin group name configured as part of origin groups param.
    originName: 'origin1'
    hostName: 'hostname.com.au'
    httpPort: '80' // Optional.
    httpsPort: '443' // Optional.
    originHostHeader: 'string' // Optional.
    enforceCertificateNameCheck: true // Optional.
    priority: '1' // Optional.
    weight: '1000' // Optional.
    sharedPrivateLinkResource: { // Optional.
      privateLink: {
        id: 'privateLinkResourceId'
      }
      privateLinkLocation: 'location'
      status: 'Approved'
      requestMessage: 'Please approve this request to allow Front Door to access the container app'
    }
  }
})
param origins array

@description('Optional. Secrets to deploy to Frontdoor. Required if customer certificates are used to secure endpoints.')
@metadata({
  doclink: 'https://learn.microsoft.com/en-us/azure/templates/microsoft.cdn/profiles/secrets?pivots=deployment-language-bicep'
  example: {
    secretName: 'secret1'
    parameters: {
      type: 'CustomerCertificate'
      certificateSecretId: 'secret resource id to secret in key vault containing certificate'
    }
  }
})
param secrets array = []

@description('Optional. Custom domains to deploy to Frontdoor.')
@metadata({
  doclink: 'https://learn.microsoft.com/en-us/azure/templates/microsoft.cdn/profiles/customdomains?pivots=deployment-language-bicep'
  example: {
    customDomainName: 'myCustomDomain'
    hostName: 'host.com.au'
    dnsZoneId: 'resource id of DNS Zone'
    tlsSettings: {
      certificateType: 'ManagedCertificate'
      minimumTlsVersion: 'TLS12'
    }
  }
})
param customDomains array = []

@description('Routes to deploy to Frontdoor.')
@metadata({
  doclink: 'https://learn.microsoft.com/en-us/azure/templates/microsoft.cdn/profiles/afdendpoints/routes?pivots=deployment-language-bicep'
  example: {
    routeName: 'route1'
    endpointName: 'myendpoint' // Name must match with the endpoint name configured as part of endpoints param.
    originGroupName: 'myOriginGroup' // Name must match with the origin group name configured as part of origin groups param.
    supportedProtocols: [
      'Http'
      'Https'
    ]
    patternsToMatch: [
      '/*'
    ]
    forwardingProtocol: 'HttpsOnly'
    customDomains: [ 'myCustomDomain' ] // Name must match with the custom domain name configured as part of customDomains  param.
    ruleSets: [ 'ruleSet1' ] // Name must match with the ruleSet name configured as part of ruleSets.
    linkToDefaultDomain: 'Enabled'
    httpsRedirect: 'Enabled'
  }
})
param routes array

@description('RuleSets to deploy to Frontdoor.')
@metadata({
  doclink: [
    'https://learn.microsoft.com/en-us/azure/templates/microsoft.cdn/profiles/rulesets?pivots=deployment-language-bicep'
    'https://learn.microsoft.com/en-us/azure/templates/microsoft.cdn/profiles/rulesets/rules?pivots=deployment-language-bicep'
  ]
  example: {
    ruleSetName: 'MaintenancePageRuleSet'
    rules: [
      {
        ruleName: 'MaintenancePageRedirectForExternal'
        actions: [
          {
            name: 'UrlRedirect'
            parameters: {
              redirectType: 'TemporaryRedirect'
              typeName: 'DeliveryRuleUrlRedirectActionParameters'
              destinationProtocol: 'Https'
            }
          }
        ]
        conditions: [
          {
            name: 'RemoteAddress'
            parameters: {
              operator: 'IPMatch'
              typeName: 'DeliveryRuleRemoteAddressConditionParameters'
              negateCondition: false
              matchValues: [
                '200.1.1.1'
              ]
              transforms: []
            }
          }
        ]
        matchProcessingBehavior: 'Stop'
        order: 10
      }
    ]
  }
})
param ruleSets array = []

@description('Security Policies to deploy to Frontdoor.')
@metadata({
  example: {
    name: 'securityPolicy1'
    firewallPolicyId: 'resource id to Front door WAF Policy'
    endpoints: [ 'myendpoint' ] // Names must match with the endpoint name configured as part of endpoints param.
    customDomains: [ 'myCustomDomain' ] // Name(s) must match with the custom domain name configured as part of customDomains param.
  }
})
param securityPolicies array = []

resource profile 'Microsoft.Cdn/profiles@2022-11-01-preview' existing = {
  name: profileName
}

resource endpoint 'Microsoft.Cdn/profiles/afdEndpoints@2022-11-01-preview' = [for e in endpoints: {
  parent: profile
  name: e.name
  location: 'global'
  properties: {
    enabledState: contains(e, 'enabledState') ? e.enabledState : 'Enabled'
    autoGeneratedDomainNameLabelScope: contains(e, 'autoGeneratedDomainNameLabelScope') ? e.autoGeneratedDomainNameLabelScope : 'TenantReuse'
  }
}]

resource originGroup 'Microsoft.Cdn/profiles/originGroups@2022-11-01-preview' = [for og in originGroups: {
  parent: profile
  name: og.name
  properties: {
    loadBalancingSettings: contains(og, 'loadBalancingSettings') ? {
      sampleSize: contains(og.loadBalancingSettings, 'sampleSize') ? og.loadBalancingSettings.sampleSize : 4
      successfulSamplesRequired: contains(og.loadBalancingSettings, 'successfulSamplesRequired') ? og.loadBalancingSettings.successfulSamplesRequired : 3
      additionalLatencyInMilliseconds: contains(og.loadBalancingSettings, 'additionalLatencyInMilliseconds') ? og.loadBalancingSettings.additionalLatencyInMilliseconds : 50
    } : {
      sampleSize: 4
      successfulSamplesRequired: 3
      additionalLatencyInMilliseconds: 50
    }
    healthProbeSettings: contains(og, 'healthProbeSettings') ? {
      probePath: contains(og.healthProbeSettings, 'probePath') ? og.healthProbeSettings.probePath : '/'
      probeRequestType: contains(og.healthProbeSettings, 'probeRequestType') ? og.healthProbeSettings.probeRequestType : 'HEAD'
      probeProtocol: contains(og.healthProbeSettings, 'probeProtocol') ? og.healthProbeSettings.probeProtocol : 'Http'
      probeIntervalInSeconds: contains(og.healthProbeSettings, 'probeIntervalInSeconds') ? og.healthProbeSettings.probeIntervalInSeconds : 240
    } : {}
    sessionAffinityState: contains(og, 'sessionAffinityState') ? og.sessionAffinityState : 'Disabled'
  }
}]

resource origin 'Microsoft.Cdn/profiles/originGroups/origins@2022-11-01-preview' = [for o in origins: {
  dependsOn: [
    originGroup
  ]
  #disable-next-line use-parent-property
  name: '${profile.name}/${o.originGroupName}/${o.originName}'
  properties: {
    hostName: o.hostName
    httpPort: contains(o, 'httpPort') ? o.httpPort : 80
    httpsPort: contains(o, 'httpsPort') ? o.httpsPort : 443
    originHostHeader: contains(o, 'originHostHeader') ? o.originHostHeader : o.hostName
    enforceCertificateNameCheck: contains(o, 'enforceCertificateNameCheck') ? o.enforceCertificateNameCheck : true
    priority: contains(o, 'priority') ? o.priority : 1
    weight: contains(o, 'weight') ? o.weight : 1000
    sharedPrivateLinkResource: contains(o, 'sharedPrivateLinkResource') ? o.sharedPrivateLinkResource : null
    enabledState: contains(o, 'enabledState') ? o.enabledState : 'Enabled'
  }
}]

resource secret 'Microsoft.Cdn/profiles/secrets@2022-11-01-preview' = [for s in secrets: {
  parent: profile
  name: s.secretName
  properties: {
    parameters: {
      type: 'CustomerCertificate'
      useLatestVersion: true
      secretSource: {
        #disable-next-line use-resource-id-functions
        id: s.parameters.certificateSecretId
      }
    }
  }
}]

resource customDomain 'Microsoft.Cdn/profiles/customDomains@2022-11-01-preview' = [for c in customDomains: {
  parent: profile
  dependsOn: [
    secret // secrets must exist before custom domains are created
  ]
  name: replace(c.customDomainName, '.', '-')
  properties: {
    hostName: c.hostName
    azureDnsZone: {
      #disable-next-line use-resource-id-functions
      id: c.dnsZoneId
    }
    tlsSettings: {
      certificateType: c.tlsSettings.certificateType
      minimumTlsVersion: 'TLS12'
      secret: c.tlsSettings.certificateType == 'CustomerCertificate' ? {
        id: az.resourceId('Microsoft.Cdn/profiles/secrets', profile.name, c.tlsSettings.secretName)
      } : null
    }
  }
}]

resource ruleset 'Microsoft.Cdn/profiles/ruleSets@2022-11-01-preview' = [for rs in ruleSets: {
  name: rs.ruleSetName
  parent: profile
}]

module rulesModule 'rules.bicep' = [for (rs, i) in ruleSets: {
  name: 'rulesModuleDeploy${i}'
  dependsOn: [
    ruleset
  ]
  params: {
    profileName: profileName
    rulesetName: rs.ruleSetName
    rules: rs.rules
  }
}]

resource route 'Microsoft.Cdn/profiles/afdEndpoints/routes@2022-11-01-preview' = [for r in routes: {
  dependsOn: [
    endpoint
    origin
    customDomain
    ruleset
  ]
  #disable-next-line use-parent-property
  name: '${profile.name}/${r.endpointName}/${r.routeName}'
  properties: {
    originGroup: {
      id: az.resourceId('Microsoft.Cdn/profiles/origingroups', profile.name, r.originGroupName)
    }
    supportedProtocols: contains(r, 'supportedProtocols') ? r.supportedProtocols : [ 'Https' ]
    patternsToMatch: contains(r, 'patternsToMatch') ? r.patternsToMatch : []
    forwardingProtocol: contains(r, 'forwardingProtocol') ? r.forwardingProtocol : 'HttpsOnly'
    customDomains: [for c in contains(r, 'customDomains') ? r.customDomains : []: {
      id: az.resourceId('Microsoft.Cdn/profiles/customdomains', profile.name, replace(c.name, '.', '-'))
    }]
    ruleSets: [for rs in contains(r, 'ruleSets') ? r.ruleSets : []: {
      id: az.resourceId('Microsoft.Cdn/profiles/ruleSets', profile.name, rs.name)
    }]
    linkToDefaultDomain: contains(r, 'linkToDefaultDomain') ? r.linkToDefaultDomain : 'Enabled'
    httpsRedirect: contains(r, 'httpsRedirect') ? r.httpsRedirect : 'Enabled'
    cacheConfiguration: contains(r, 'cacheConfiguration') ? r.cacheConfiguration : null
  }
}]

// Create the policy associations by analysing the attached custom names and endpoints and building the resource identifier for each.
// this technique is used because the domain associations requires a single array with endpoints and custom domains.

// Associations are 2-levels deep within the security policy resource and due to bicep's limted nested loop support lambda functions have been utilised.
var policyCustomDomainsAssociations = map(filter(securityPolicies, sp => !empty(sp.customDomains)), sp => {
    policyName: sp.policyName
    ids: map(sp.customDomains, d => az.resourceId('Microsoft.Cdn/profiles/customDomains', profile.name, replace(d.name, '.', '-')))
  })

var policyEndpointAssociations = map(filter(securityPolicies, sp => !empty(sp.endpoints)), sp => {
    policyName: sp.policyName
    ids: map(sp.endpoints, ep => az.resourceId('Microsoft.Cdn/profiles/afdEndpoints', profile.name, ep.name))
  })

var policyDomainAssociations = union(policyCustomDomainsAssociations, policyEndpointAssociations)
// this union produces the following array
// [
//   {
//     policyName: 'xx'
//     ids: [
//       '.../Microsoft.Cdn/profiles/../customDomains/customDomain1'
//     ]
//   }
//   {
//     policyName: 'xx'
//     ids: [
//       '.../Microsoft.Cdn/profiles/../afdEndpoints/endpoint1'
//     ]
//   }
//   {
//     policyName: 'yy'
//     ids: [
//       '.../Microsoft.Cdn/profiles/../afdEndpoints/endpoint2'
//     ]
//   }
// ]
// During the policy deployment, the template will extract the ids and flatten the array

// For policy xx the array will be
//     [
//       '.../Microsoft.Cdn/profiles/../customDomains/customDomain1'
//       '.../Microsoft.Cdn/profiles/../afdEndpoints/endpoint1'
//     ]

// For policy yy the array will be
//     [
//       '.../Microsoft.Cdn/profiles/../afdEndpoints/endpoint2'
//     ]

resource policy 'Microsoft.Cdn/profiles/securityPolicies@2022-11-01-preview' = [for s in securityPolicies: {
  parent: profile
  dependsOn: [
    endpoint
    customDomain
  ]
  name: s.policyName
  properties: {
    parameters: {
      type: 'WebApplicationFirewall'
      associations: [
        {
          patternsToMatch: [ '/*' ]
          domains: [for id in flatten(map(filter(policyDomainAssociations, f => f.policyName == s.policyName), policy => policy.ids)): {
            #disable-next-line use-resource-id-functions
            id: id
          }]
        }
      ]
      wafPolicy: {
        #disable-next-line use-resource-id-functions
        id: s.firewallPolicyId
      }
    }
  }
}]

@description('The endpoints of the deployed Azure Frontdoor Profile.')
output endpoints array = [for (ep, i) in endpoints: {
  id: endpoint[i].id
  name: endpoint[i].name
  hostName: endpoint[i].properties.hostName
}]

@description('The custom domains of the deployed Azure Frontdoor Profile.')
output customDomains array = [for (domain, i) in customDomains: {
  id: customDomain[i].id
  name: customDomain[i].name
  hostname: customDomain[i].properties.hostName
  status: customDomain[i].properties.deploymentStatus
  state: customDomain[i].properties.provisioningState
}]
@description('The custom domain validations of the deployed Azure Frontdoor Profile.')
output customDomainValidations array = [for (domain, i) in customDomains: {
  dnsTxtRecordName: '_dnsauth.${customDomain[i].properties.hostName}'
  dnsTxtRecordValue: customDomain[i].properties.validationProperties.validationToken
  expiry: customDomain[i].properties.validationProperties.expirationDate
}]

@description('The security policies of the deployed Azure Frontdoor Profile.')
output securityPolicies array = [for (sp, i) in securityPolicies: {
  id: policy[i].id
  name: policy[i].name
  associations: policy[i].properties.parameters.associations
}]

@description('The ruleSets of the deployed Azure Frontdoor Profile.')
output ruleSets array = [for (rs, i) in ruleSets: {
  id: ruleset[i].id
  name: ruleset[i].name
}]
